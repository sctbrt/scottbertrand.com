generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

model accounts {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  users             users   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// RETENTION: Consider periodic cleanup of activity_logs and audit_logs older than 90 days.
// At scale, implement a scheduled task (Vercel Cron or external) to DELETE WHERE createdAt < NOW() - INTERVAL 90 DAY.
// For compliance, archive to cold storage (e.g., Vercel Blob) before deleting.
model activity_logs {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  entityType String
  entityId   String?
  details    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  users      users?   @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([entityType, entityId])
  @@index([userId])
}

// Security audit logs - dedicated table for security-relevant events
// Separate from activity_logs for security isolation and retention policies
model audit_logs {
  id           String   @id @default(cuid())
  eventType    String   // AUTH_LOGIN_SUCCESS, RATE_LIMIT_EXCEEDED, etc.
  severity     String   // INFO, WARNING, ERROR, CRITICAL
  userId       String?
  sessionId    String?
  ip           String
  userAgent    String?
  path         String?
  method       String?
  resourceType String?  // LEAD, CLIENT, FILE, etc.
  resourceId   String?
  details      String?  // JSON string for flexible data
  success      Boolean
  createdAt    DateTime @default(now())

  @@index([createdAt])
  @@index([eventType])
  @@index([severity])
  @@index([userId])
  @@index([ip])
  @@index([resourceType, resourceId])
}

model clients {
  id           String     @id @default(cuid())
  userId       String     @unique
  companyName  String?
  contactName  String
  contactEmail String
  phone        String?
  website      String?
  notes        String?
  isArchived   Boolean    @default(false)
  // Intake system fields (Section 4.2)
  locationCity    String?    @map("location_city")
  locationCountry String?    @map("location_country")
  newOrReturning  ClientType @default(NEW) @map("new_or_returning")
  intakeStatus    IntakeStatus @default(NOT_STARTED) @map("intake_status")
  fitScore        Int?         @map("fit_score")        // Internal 1-10 score
  fitDecision     FitDecision? @map("fit_decision")     // Required before routing
  assignedPath    RoutingPath? @map("assigned_path")    // Focus/Core/Hold
  lastReviewedAt  DateTime?    @map("last_reviewed_at")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  users        users      @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoices     invoices[]
  leads        leads[]
  projects     projects[]
  intakeSubmissions intake_submissions[]
}

model comments {
  id          String       @id @default(cuid())
  projectId   String
  milestoneId String?
  fileId      String?
  authorId    String
  content     String
  isInternal  Boolean      @default(false)
  isRead      Boolean      @default(false)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  users       users        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  file_assets file_assets? @relation(fields: [fileId], references: [id])
  milestones  milestones?  @relation(fields: [milestoneId], references: [id])
  projects    projects     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([milestoneId])
  @@index([projectId])
}

model file_assets {
  id           String          @id @default(cuid())
  filename     String
  originalName String
  mimeType     String
  size         Int
  url          String
  accessLevel  FileAccessLevel @default(PRIVATE)
  projectId    String?
  description  String?
  uploadedById String?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  comments     comments[]
  projects     projects?       @relation(fields: [projectId], references: [id])
  invoices     invoices[]
}

model invoices {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  clientId      String
  projectId     String?
  status        InvoiceStatus @default(DRAFT)
  subtotal      Decimal       @db.Decimal(10, 2)
  tax           Decimal       @default(0) @db.Decimal(10, 2)
  total         Decimal       @db.Decimal(10, 2)
  currency      String        @default("CAD")
  dueDate       DateTime?
  paidAt        DateTime?
  lineItems     Json?
  notes         String?
  pdfFileId     String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  clients       clients       @relation(fields: [clientId], references: [id])
  file_assets   file_assets?  @relation(fields: [pdfFileId], references: [id])
  projects      projects?     @relation(fields: [projectId], references: [id])
}

// FUTURE: Add emailHash String? @unique column for efficient encrypted email search.
// SHA-256 hash of normalized (lowercased, trimmed) email enables lookups without decrypting all rows.
// Migration: backfill from existing encrypted emails, then index on emailHash.
model leads {
  id                  String             @id @default(cuid())
  email               String
  name                String?
  companyName         String?
  website             String?
  phone               String?
  service             String?
  message             String?
  source              String?
  status              LeadStatus         @default(NEW)
  isSpam              Boolean            @default(false)
  formData            Json?
  internalNotes       String?
  contactedAt         DateTime?
  qualifiedAt         DateTime?
  convertedToClientId String?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  createdById         String?
  clients             clients?           @relation(fields: [convertedToClientId], references: [id])
  users               users?             @relation(fields: [createdById], references: [id])
  service_templates   service_templates? @relation(fields: [service], references: [slug])
}

model milestones {
  id               String          @id @default(cuid())
  projectId        String
  name             String
  description      String?
  status           MilestoneStatus @default(PENDING)
  dueDate          DateTime?
  completedAt      DateTime?
  requiresApproval Boolean         @default(false)
  approvedAt       DateTime?
  approvalNotes    String?
  sortOrder        Int             @default(0)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  comments         comments[]
  projects         projects        @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

model project_service_instances {
  id                String            @id @default(cuid())
  projectId         String
  serviceTemplateId String
  customPrice       Decimal?          @db.Decimal(10, 2)
  customScope       Json?
  notes             String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  projects          projects          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  service_templates service_templates @relation(fields: [serviceTemplateId], references: [id])
}

model projects {
  id                        String                      @id @default(cuid())
  publicId                  String                      @unique @default(cuid()) @map("public_id")
  name                      String
  description               String?
  status                    ProjectStatus               @default(DRAFT)
  // Portal stage (client-visible): scheduled, in_delivery, in_review, approved, released, complete
  portalStage               PortalStage                 @default(SCHEDULED) @map("portal_stage")
  // Payment gating
  paymentStatus             PaymentStatus               @default(UNPAID) @map("payment_status")
  paymentProvider           PaymentProvider?            @map("payment_provider")
  paymentRequired           Boolean                     @default(true) @map("payment_required")
  paidAt                    DateTime?                   @map("paid_at")
  lastPaymentEventId        String?                     @unique @map("last_payment_event_id")
  // Stripe Payment Link integration
  stripePaymentLinkId       String?                     @map("stripe_payment_link_id")
  stripePaymentLinkUrl      String?                     @map("stripe_payment_link_url")
  stripeCheckoutSessionId   String?                     @map("stripe_checkout_session_id")
  stripePaymentIntentId     String?                     @map("stripe_payment_intent_id")
  clientId                  String
  serviceTemplateId         String?
  startDate                 DateTime?
  targetEndDate             DateTime?
  actualEndDate             DateTime?
  previewUrl                String?
  // Scope fields for portal display
  scopeIncluded             Json?                       @map("scope_included") // Array of included items
  scopeExcluded             String?                     @map("scope_excluded") // Single sentence
  revisionPolicy            String?                     @map("revision_policy")
  // Milestone tracking for portal
  nextMilestoneLabel        String?                     @map("next_milestone_label")
  nextMilestoneDueAt        DateTime?                   @map("next_milestone_due_at")
  lastUpdateAt              DateTime                    @default(now()) @map("last_update_at")
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime                    @updatedAt
  comments                  comments[]
  deliverables              deliverables[]
  file_assets               file_assets[]
  invoices                  invoices[]
  milestones                milestones[]
  project_service_instances project_service_instances[]
  clients                   clients                     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  service_templates         service_templates?          @relation(fields: [serviceTemplateId], references: [id])
  tasks                     tasks[]
  feedbacks                 feedbacks[]
  signoffs                  signoffs[]
  paymentEvents             payment_events[]

  @@index([publicId])
}

model service_templates {
  id                        String                      @id @default(cuid())
  name                      String
  slug                      String                      @unique
  description               String?
  price                     Decimal                     @db.Decimal(10, 2)
  currency                  String                      @default("CAD")
  estimatedDays             Int?
  scope                     Json?
  deliverables              Json?
  checklistItems            Json?
  isActive                  Boolean                     @default(true)
  sortOrder                 Int                         @default(0)
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime                    @updatedAt
  leads                     leads[]
  project_service_instances project_service_instances[]
  projects                  projects[]
}

model sessions {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  users        users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model tasks {
  id              String     @id @default(cuid())
  projectId       String
  title           String
  description     String?
  status          TaskStatus @default(PENDING)
  priority        Int        @default(0)
  dueDate         DateTime?
  completedAt     DateTime?
  assigneeId      String?
  sortOrder       Int        @default(0)
  isClientVisible Boolean    @default(false)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  users           users?     @relation(fields: [assigneeId], references: [id])
  projects        projects   @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

model users {
  id            String          @id @default(cuid())
  email         String          @unique
  name          String?
  emailVerified DateTime?
  image         String?
  role          Role            @default(CLIENT)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  accounts      accounts[]
  activity_logs activity_logs[]
  clients       clients?
  comments      comments[]
  leads         leads[]
  sessions      sessions[]
  tasks         tasks[]
}

model verification_tokens {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// INTAKE SYSTEM MODELS (Implementation Guide Sections 4, 5, 6)
// ============================================

// Intake Submissions - versioned, immutable records of intake responses
// Each submission is locked on submit (Section 4.2.B)
model intake_submissions {
  id              String           @id @default(cuid())
  clientId        String           @map("client_id")

  // Metadata (Section 4.2.B)
  intakeType      IntakeChannel    @map("intake_type")     // guided | self_guided | ai_phone
  entrySource     EntrySource      @map("entry_source")    // web | phone_ai_beside | referral | other
  submittedAt     DateTime?        @map("submitted_at")
  timeToComplete  Int?             @map("time_to_complete") // seconds
  clientConfidence Int?            @map("client_confidence") // 1-5 self-assessment

  // Status tracking (Section 5.1)
  status          SubmissionStatus @default(DRAFT)

  // Readiness Signals - structured (Section 4.2.C)
  problemClarity   Int?            @map("problem_clarity")   // 1-5
  urgency          UrgencyLevel?                             // now | 1-3 months | later
  budgetBand       BudgetBand?     @map("budget_band")       // bands, not exact
  decisionAuthority DecisionAuthority? @map("decision_authority") // yes | shared | no
  scopeType        ScopeType?      @map("scope_type")        // web | brand | both | unsure

  // Narrative - constrained (Section 4.2.D)
  whatsNotWorking  String?         @map("whats_not_working")  @db.VarChar(500)
  successLooksLike String?         @map("success_looks_like") @db.VarChar(300)

  // AI Phone Intake (Beside App) specific fields
  besideSummary       String?      @map("beside_summary")        // Long text from Beside
  besideTranscriptUrl String?      @map("beside_transcript_url") // File/link

  // Routing outcome (Section 5.2)
  routingOutcome   RoutingOutcome? @map("routing_outcome")
  routingDecidedAt DateTime?       @map("routing_decided_at")
  routingNotes     String?         @map("routing_notes")

  // Internal review (Section 6.5)
  reviewedAt       DateTime?       @map("reviewed_at")
  reviewedById     String?         @map("reviewed_by_id")

  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  client           clients         @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([status])
  @@index([submittedAt])
  @@index([intakeType])
}

// Pricing access magic links (for gated pricing page)
// Uses UUID to match existing bertrandbrands.com schema
model pricing_magic_links {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email     String
  tokenHash String    @unique @map("token_hash")
  expiresAt DateTime  @map("expires_at") @db.Timestamptz
  usedAt    DateTime? @map("used_at") @db.Timestamptz
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@index([email, createdAt])
}

// Booking access tokens (admin-generated links for gated Calendly scheduling)
// Uses UUID to match existing bertrandbrands.com schema
model booking_access_tokens {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clientId    String    @map("client_id")
  bookingType String    @map("booking_type")
  tokenHash   String    @unique @map("token_hash")
  expiresAt   DateTime  @map("expires_at") @db.Timestamptz
  usedAt      DateTime? @map("used_at") @db.Timestamptz
  createdBy   String?   @map("created_by")
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@index([clientId])
}

// Booking sessions (active booking page access after token redemption)
// Uses UUID to match existing bertrandbrands.com schema
model booking_sessions {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clientId    String   @map("client_id")
  bookingType String   @map("booking_type")
  clientEmail String   @map("client_email")
  expiresAt   DateTime @map("expires_at") @db.Timestamptz
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([expiresAt])
}

// Pricing access sessions (active pricing page access)
// Uses UUID to match existing bertrandbrands.com schema
model pricing_sessions {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email     String
  expiresAt DateTime @map("expires_at") @db.Timestamptz
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([expiresAt])
}

enum FileAccessLevel {
  PUBLIC
  PRIVATE
  CLIENT_VISIBLE
}

enum InvoiceStatus {
  DRAFT
  SENT
  VIEWED
  PAID
  OVERDUE
  CANCELLED
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  CONVERTED
  DISQUALIFIED
  ARCHIVED
}

enum MilestoneStatus {
  PENDING
  IN_PROGRESS
  AWAITING_APPROVAL
  APPROVED
  COMPLETED
}

enum ProjectStatus {
  DRAFT
  PENDING_APPROVAL
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

enum Role {
  INTERNAL_ADMIN
  CLIENT
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  BLOCKED
}

// Portal-specific enums for Delivery Room
enum PortalStage {
  SCHEDULED
  IN_DELIVERY
  IN_REVIEW
  APPROVED
  RELEASED
  COMPLETE
}

enum PaymentStatus {
  UNPAID
  PAID
  PARTIALLY_REFUNDED
  REFUNDED
}

enum PaymentProvider {
  STRIPE
  MANUAL
}

enum DeliverableState {
  DRAFT
  REVIEW
  FINAL
}

enum FeedbackType {
  APPROVE
  APPROVE_MINOR
  NEEDS_REVISION
}

enum SignoffAction {
  APPROVED_AND_RELEASED
  SIGNED_OFF
}

// Deliverables - versioned files with watermarking support
model deliverables {
  id                  String           @id @default(cuid())
  projectId           String           @map("project_id")
  title               String
  version             Int              @default(1)
  state               DeliverableState @default(DRAFT)
  // File URLs - preview is watermarked, download is gated
  filePreviewUrl      String?          @map("file_preview_url")   // Watermarked version
  fileDownloadUrl     String?          @map("file_download_url")  // Clean version (gated)
  mimeType            String?          @map("mime_type")
  fileSize            Int?             @map("file_size")
  checksum            String?
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")
  project             projects         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  feedbacks           feedbacks[]

  @@unique([projectId, version])
  @@index([projectId])
  @@index([projectId, state])
}

// Feedback - structured client responses tied to deliverable versions
model feedbacks {
  id               String       @id @default(cuid())
  projectId        String       @map("project_id")
  deliverableId    String       @map("deliverable_id")
  submittedByName  String       @map("submitted_by_name")
  submittedByEmail String?      @map("submitted_by_email")
  type             FeedbackType
  notes            String?
  createdAt        DateTime     @default(now()) @map("created_at")
  project          projects     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  deliverable      deliverables @relation(fields: [deliverableId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([deliverableId])
}

// Sign-offs - approval event log
model signoffs {
  id             String        @id @default(cuid())
  projectId      String        @map("project_id")
  deliverableId  String        @map("deliverable_id")
  signedByName   String        @map("signed_by_name")
  signedByEmail  String?       @map("signed_by_email")
  signedAt       DateTime      @default(now()) @map("signed_at")
  action         SignoffAction
  project        projects      @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
}

// Payment events - audit log for Stripe webhook events (idempotency + tracking)
model payment_events {
  id          String          @id @default(cuid())
  provider    PaymentProvider
  eventId     String          @unique @map("event_id") // Stripe event ID for idempotency
  eventType   String          @map("event_type")       // checkout.session.completed, etc.
  processedAt DateTime        @default(now()) @map("processed_at")
  projectId   String?         @map("project_id")
  project     projects?       @relation(fields: [projectId], references: [id])
  payloadHash String?         @map("payload_hash")     // SHA256 for debugging
  metadata    Json?                                    // Relevant extracted data
  status      String          @default("SUCCESS")      // SUCCESS, FAILED, UNMATCHED
  errorMsg    String?         @map("error_msg")

  @@index([projectId])
  @@index([eventId])
  @@index([processedAt])
}

// ============================================
// INTAKE SYSTEM ENUMS (Implementation Guide Sections 4-6)
// ============================================

// Client type (Section 4.2.A)
enum ClientType {
  NEW
  RETURNING
}

// Intake status on client record (Section 5.1)
enum IntakeStatus {
  NOT_STARTED
  DRAFT
  SUBMITTED
  REVIEWED
  ROUTED
  CLOSED
}

// Fit decision - required before routing (Section 5.3)
enum FitDecision {
  YES
  MAYBE
  NO
}

// Routing path assignment (Section 5.2)
enum RoutingPath {
  FOCUS_STUDIO
  CORE_SERVICES
  HOLD
}

// Submission status - tracks workflow state (Section 5.1)
enum SubmissionStatus {
  DRAFT
  SUBMITTED
  REVIEWED
  ROUTED
  CLOSED
}

// Intake channel types (Section 1.2)
enum IntakeChannel {
  GUIDED         // Human-led video
  SELF_GUIDED    // Asynchronous web form
  AI_PHONE       // Beside App phone intake
}

// Entry source tracking (Section 4.2.B)
enum EntrySource {
  WEB
  PHONE_AI_BESIDE
  REFERRAL
  OTHER
}

// Readiness signals (Section 4.2.C)
enum UrgencyLevel {
  NOW
  ONE_TO_THREE_MONTHS
  LATER
}

enum BudgetBand {
  UNDER_1K
  ONE_TO_3K
  THREE_TO_5K
  FIVE_TO_10K
  OVER_10K
  NOT_SURE
}

enum DecisionAuthority {
  YES
  SHARED
  NO
}

enum ScopeType {
  WEB
  BRAND
  BOTH
  UNSURE
}

// Routing outcomes - exclusive (Section 5.2)
enum RoutingOutcome {
  FOCUS_STUDIO_ELIGIBLE
  CORE_SERVICES_ELIGIBLE
  NEEDS_CLARIFICATION
  NOT_A_FIT
  DEFERRED
}
